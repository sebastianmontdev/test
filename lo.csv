¬°Claro! Este es un proyecto de desarrollo de un sistema de gesti√≥n de archivos en consola con persistencia CSV en Python. Es un excelente ejercicio que cubre los requisitos funcionales y t√©cnicos solicitados.

Aqu√≠ tienes el c√≥digo completo, separado en los archivos sugeridos, y un borrador para el README.md.

üíæ Estructura del Proyecto
El proyecto sigue la organizaci√≥n m√≠nima sugerida:

GalacticLibraryKeeper/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ auth.py
‚îú‚îÄ‚îÄ storage.py
‚îú‚îÄ‚îÄ visitors.py
‚îú‚îÄ‚îÄ artifacts.py
‚îú‚îÄ‚îÄ utils.py
‚îú‚îÄ‚îÄ admin_access.csv
‚îú‚îÄ‚îÄ visitantes.csv
‚îî‚îÄ‚îÄ artefactos.csv
‚îî‚îÄ‚îÄ README.md
üõ†Ô∏è C√≥digo Fuente
1. storage.py (Manejo de Persistencia CSV)
Este m√≥dulo maneja la lectura y escritura gen√©rica en archivos CSV.

Python

import csv
import os

# Define los nombres de los archivos
ADMIN_FILE = 'admin_access.csv'
VISITORS_FILE = 'visitantes.csv'
ARTIFACTS_FILE = 'artefactos.csv'

def load_data(filename, default_header):
    """
    Carga los datos de un archivo CSV. Si no existe, crea el archivo con el encabezado.
    Retorna una lista de diccionarios con los datos.
    """
    data = []
    if not os.path.exists(filename):
        print(f"Creando archivo: {filename}")
        save_data(filename, [], default_header)
        return []

    try:
        with open(filename, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            data = list(reader)
    except Exception as e:
        print(f"Error al leer {filename}: {e}")
    
    return data

def save_data(filename, data_list, header):
    """
    Guarda una lista de diccionarios en un archivo CSV.
    """
    try:
        with open(filename, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.DictWriter(file, fieldnames=header)
            writer.writeheader()
            writer.writerows(data_list)
        return True
    except Exception as e:
        print(f"Error al guardar en {filename}: {e}")
        return False

# --- Inicializaci√≥n de Archivos ---

# 1. admin_access.csv
ADMIN_HEADER = ['username', 'password', 'role']
ADMIN_DATA = [
    {'username': 'GLK_Admin', 'password': 'superpassword2487', 'role': 'SUPERADMIN'}
]

if not os.path.exists(ADMIN_FILE):
    save_data(ADMIN_FILE, ADMIN_DATA, ADMIN_HEADER)

# 2. visitantes.csv
VISITORS_HEADER = ['id', 'nombre', 'especie', 'estado']
if not os.path.exists(VISITORS_FILE):
    save_data(VISITORS_FILE, [], VISITORS_HEADER)

# 3. artefactos.csv
ARTIFACTS_HEADER = ['codigo', 'descripcion', 'rareza', 'estatus']
if not os.path.exists(ARTIFACTS_FILE):
    save_data(ARTIFACTS_FILE, [], ARTIFACTS_HEADER)
2. auth.py (Inicio de Sesi√≥n Recursivo)
Este m√≥dulo maneja el inicio de sesi√≥n del administrador, usando una funci√≥n recursiva para reintentos.

Python

import storage
import hashlib

# Usa el header definido en storage.py
ADMIN_HEADER = storage.ADMIN_HEADER

def load_admin_credentials():
    """Carga las credenciales del √∫nico administrador del CSV."""
    # Los datos son cargados como lista de diccionarios
    admin_data_list = storage.load_data(storage.ADMIN_FILE, ADMIN_HEADER)
    if admin_data_list:
        # Retorna el primer y √∫nico registro como diccionario
        return admin_data_list[0]
    return None

def login(attempts=3):
    """
    Funci√≥n recursiva para manejar el inicio de sesi√≥n del administrador.
    """
    if attempts == 0:
        print("\nüö´ Has agotado los intentos. Acceso denegado. Cerrando sistema.")
        return False

    admin_creds = load_admin_credentials()
    if not admin_creds:
        print("\n‚ùå Error: No se encontraron credenciales de administrador.")
        return False

    print(f"\nüîë INTENTO DE LOGIN - Quedan {attempts} intentos")
    username = input("   ID de administrador: ").strip()
    password = input("   Contrase√±a: ").strip()

    # Validaci√≥n
    if username == admin_creds['username'] and password == admin_creds['password']:
        print("\n‚úÖ Acceso concedido. Bienvenido, SUPERADMIN.")
        return True
    else:
        print("\n‚ö†Ô∏è Credenciales incorrectas.")
        # Llamada recursiva con un intento menos
        return login(attempts - 1)
3. utils.py (Funciones Auxiliares con Args y Kwargs)
Este m√≥dulo contiene funciones auxiliares que demuestran el uso de *args y **kwargs.

Python

def format_data_for_display(data_list):
    """
    Recibe una lista de diccionarios y la convierte en una lista de tuplas 
    para su visualizaci√≥n (Tupla: colecci√≥n inmutable).
    """
    if not data_list:
        return []
        
    # El encabezado es la clave del primer diccionario
    header = list(data_list[0].keys())
    
    # Crea una lista de tuplas. La primera tupla es el encabezado.
    display_list = [tuple(header)]
    for item in data_list:
        # Cada fila es una tupla con los valores
        display_list.append(tuple(item.values()))
        
    return display_list

def display_statistics(stats_dict, *args):
    """
    Muestra estad√≠sticas con un t√≠tulo principal y subt√≠tulos opcionales.
    Uso de *args para subt√≠tulos din√°micos.
    """
    print("\nüìä --- REPORTE ESTAD√çSTICO --- üìä")
    
    # Imprime los subt√≠tulos usando *args
    if args:
        for subtitle in args:
            print(f"| {subtitle.upper()} |")
            
    # Imprime las estad√≠sticas del diccionario
    for key, value in stats_dict.items():
        print(f"  - {key.replace('_', ' ').title()}: **{value}**")
        
    print("---------------------------------")

def classify_by_rarity(data_list, **kwargs):
    """
    Clasifica los artefactos por nivel de rareza y aplica filtros adicionales 
    usando **kwargs.
    Retorna un diccionario: {'rareza': [lista_de_artefactos]}
    """
    classified = {}
    
    for item in data_list:
        # Filtra por **kwargs (ej: estatus='Almacenado')
        is_filtered = True
        for key, value in kwargs.items():
            if item.get(key) != value:
                is_filtered = False
                break
        
        if is_filtered and 'rareza' in item:
            rarity = item['rareza']
            if rarity not in classified:
                classified[rarity] = []
            classified[rarity].append(item)
            
    return classified
4. visitors.py (M√≥dulo de Visitantes)
Este m√≥dulo gestiona la l√≥gica de visitantes, incluyendo validaci√≥n de IDs √∫nicos con sets y diccionarios para los datos.

Python

import storage
import utils

VISITORS_HEADER = storage.VISITORS_HEADER

def get_visitor_ids(visitors_list):
    """Usa un SET para obtener todos los IDs de visitantes √∫nicos."""
    return {v['id'] for v in visitors_list}

def load_visitors():
    """Carga los visitantes del CSV."""
    return storage.load_data(storage.VISITORS_FILE, VISITORS_HEADER)

def save_visitors(visitors_list):
    """Guarda la lista de visitantes en el CSV."""
    return storage.save_data(storage.VISITORS_FILE, visitors_list, VISITORS_HEADER)

def register_visitor():
    """Registra un nuevo visitante."""
    visitors = load_visitors()
    current_ids = get_visitor_ids(visitors)

    print("\n--- REGISTRAR NUEVO VISITANTE ---")
    
    while True:
        v_id = input("ID √önico del Visitante: ").strip()
        if not v_id:
            print("‚ö†Ô∏è El ID no puede estar vac√≠o.")
            continue
        if v_id in current_ids:
            print("‚ùå ID ya existe. Intente con otro.")
        else:
            break

    nombre = input("Nombre: ").strip()
    especie = input("Especie (Humano/Androide/Otros): ").strip().title()
    estado = 'Activo' # Estado inicial

    # Representaci√≥n del visitante como un DICCIONARIO
    new_visitor = {
        'id': v_id,
        'nombre': nombre,
        'especie': especie,
        'estado': estado
    }

    visitors.append(new_visitor)
    if save_visitors(visitors):
        print(f"\n‚úÖ Visitante **{nombre}** registrado exitosamente con ID: **{v_id}**.")
    else:
        print("\n‚ùå Error al guardar el visitante.")

def list_visitors():
    """Lista todos los visitantes cargados, mostrando datos como TUPLAS."""
    visitors = load_visitors()
    if not visitors:
        print("\n‚ÑπÔ∏è No hay visitantes registrados.")
        return
        
    # Usamos la funci√≥n auxiliar para convertir a TUPLAS
    display_data = utils.format_data_for_display(visitors)
    
    print("\nüìú --- LISTA DE VISITANTES INTERGAL√ÅCTICOS ---")
    # Imprime el encabezado
    print(display_data[0]) 
    print("-" * 50)
    # Imprime las filas (tuplas)
    for row_tuple in display_data[1:]:
        print(row_tuple)
    print("---------------------------------------------")

def search_visitor():
    """Busca un visitante por ID."""
    v_id = input("Ingrese el ID del visitante a buscar: ").strip()
    visitors = load_visitors()
    
    found_visitor = next((v for v in visitors if v['id'] == v_id), None)
    
    if found_visitor:
        print("\nüîç VISITANTE ENCONTRADO:")
        # Muestra el diccionario encontrado
        for key, value in found_visitor.items():
            print(f"  {key.title()}: **{value}**")
        return found_visitor
    else:
        print(f"\n‚ùå Visitante con ID **{v_id}** no encontrado.")
        return None

def update_visitor_status():
    """Actualiza el estado de un visitante (Activo/Retirado)."""
    v_id = input("Ingrese el ID del visitante para actualizar estado: ").strip()
    visitors = load_visitors()
    
    for i, v in enumerate(visitors):
        if v['id'] == v_id:
            current_status = v['estado']
            new_status = 'Retirado' if current_status == 'Activo' else 'Activo'
            
            # Actualiza el diccionario
            visitors[i]['estado'] = new_status
            
            if save_visitors(visitors):
                print(f"\n‚úÖ Estado de **{v['nombre']}** actualizado: **{current_status}** -> **{new_status}**.")
            else:
                print("\n‚ùå Error al guardar la actualizaci√≥n.")
            return
            
    print(f"\n‚ùå Visitante con ID **{v_id}** no encontrado.")

def delete_visitor():
    """Elimina un visitante. (Opci√≥n B: Marcar 'Eliminado')."""
    # Justificaci√≥n de Opci√≥n B en README.md: Marcar como 'Eliminado' mantiene
    # la integridad hist√≥rica y es m√°s seguro que borrar permanentemente.
    v_id = input("Ingrese el ID del visitante a ELIMINAR (marcar): ").strip()
    visitors = load_visitors()
    
    for i, v in enumerate(visitors):
        if v['id'] == v_id:
            
            # Marcar "Eliminado" en el campo 'estado'
            visitors[i]['estado'] = 'Eliminado' 
            
            if save_visitors(visitors):
                print(f"\n‚úÖ Visitante **{v['nombre']}** con ID **{v_id}** marcado como **Eliminado**.")
            else:
                print("\n‚ùå Error al guardar la eliminaci√≥n.")
            return

    print(f"\n‚ùå Visitante con ID **{v_id}** no encontrado.")

def get_visitor_stats():
    """Calcula y muestra estad√≠sticas de visitantes."""
    visitors = load_visitors()
    
    stats = {}
    
    # Total de visitantes
    stats['total_visitantes'] = len(visitors)
    
    if not visitors:
        utils.display_statistics(stats, "Visitantes", "Informaci√≥n General")
        return
        
    # Visitantes por especie (usando un diccionario)
    species_count = {}
    for v in visitors:
        species = v['especie']
        species_count[species] = species_count.get(species, 0) + 1
    
    stats['visitantes_por_especie'] = species_count
    
    # Visitantes activos vs retirados (usando un diccionario)
    status_count = {}
    for v in visitors:
        status = v['estado']
        status_count[status] = status_count.get(status, 0) + 1
        
    stats['estado_visitantes'] = status_count

    # Usa la funci√≥n auxiliar con *args para t√≠tulos
    utils.display_statistics(
        stats, 
        "General", 
        "Por Especie", 
        "Por Estado"
    )
5. artifacts.py (M√≥dulo de Artefactos con Kwargs)
Este m√≥dulo gestiona la l√≥gica de artefactos, incluyendo el uso de **kwargs para la clasificaci√≥n.

Python

import storage
import utils

ARTIFACTS_HEADER = storage.ARTIFACTS_HEADER

def load_artifacts():
    """Carga los artefactos del CSV."""
    return storage.load_data(storage.ARTIFACTS_FILE, ARTIFACTS_HEADER)

def save_artifacts(artifacts_list):
    """Guarda la lista de artefactos en el CSV."""
    return storage.save_data(storage.ARTIFACTS_FILE, artifacts_list, ARTIFACTS_HEADER)

def get_artifact_codes(artifacts_list):
    """Usa un SET para obtener todos los c√≥digos de artefactos √∫nicos."""
    return {a['codigo'] for a in artifacts_list}

def register_artifact():
    """Registra un nuevo artefacto."""
    artifacts = load_artifacts()
    current_codes = get_artifact_codes(artifacts)

    print("\n--- REGISTRAR NUEVO ARTEFACTO ---")
    
    while True:
        code = input("C√≥digo √önico del Artefacto: ").strip()
        if not code:
            print("‚ö†Ô∏è El C√≥digo no puede estar vac√≠o.")
            continue
        if code in current_codes:
            print("‚ùå C√≥digo ya existe. Intente con otro.")
        else:
            break

    descripcion = input("Descripci√≥n: ").strip()
    
    valid_rarity = ['Bajo', 'Medio', 'Alto', 'Prohibido']
    while True:
        rareza = input(f"Nivel de rareza {valid_rarity}: ").strip().title()
        if rareza in valid_rarity:
            break
        print("‚ö†Ô∏è Nivel de rareza no v√°lido.")
        
    estatus = 'Almacenado' # Estado inicial

    # Representaci√≥n del artefacto como un DICCIONARIO
    new_artifact = {
        'codigo': code,
        'descripcion': descripcion,
        'rareza': rareza,
        'estatus': estatus
    }

    artifacts.append(new_artifact)
    if save_artifacts(artifacts):
        print(f"\n‚úÖ Artefacto **{descripcion}** (C√≥digo: {code}) registrado exitosamente.")
    else:
        print("\n‚ùå Error al guardar el artefacto.")

def list_artifacts():
    """Lista todos los artefactos cargados, mostrando datos como TUPLAS."""
    artifacts = load_artifacts()
    if not artifacts:
        print("\n‚ÑπÔ∏è No hay artefactos registrados.")
        return
        
    display_data = utils.format_data_for_display(artifacts)
    
    print("\nüìú --- LISTA DE ARTEFACTOS RECUPERADOS ---")
    print(display_data[0])
    print("-" * 50)
    for row_tuple in display_data[1:]:
        print(row_tuple)
    print("-----------------------------------------")

def search_artifact():
    """Busca un artefacto por c√≥digo."""
    code = input("Ingrese el C√≥digo del artefacto a buscar: ").strip()
    artifacts = load_artifacts()
    
    found_artifact = next((a for a in artifacts if a['codigo'] == code), None)
    
    if found_artifact:
        print("\nüîç ARTEFACTO ENCONTRADO:")
        for key, value in found_artifact.items():
            print(f"  {key.title()}: **{value}**")
        return found_artifact
    else:
        print(f"\n‚ùå Artefacto con C√≥digo **{code}** no encontrado.")
        return None

def classify_artifacts_menu():
    """
    Men√∫ para clasificar artefactos usando **kwargs.
    El filtro por defecto es 'rareza', pero se puede a√±adir un filtro por 'estatus'.
    """
    artifacts = load_artifacts()
    if not artifacts:
        print("\n‚ÑπÔ∏è No hay artefactos para clasificar.")
        return
        
    print("\n--- CLASIFICACI√ìN DE ARTEFACTOS ---")
    filter_status = input("Filtrar por estatus (dejar vac√≠o para clasificar todos): ").strip().title()
    
    filter_params = {}
    if filter_status in ['Almacenado', 'En Estudio', 'Destruido']:
        # Se pasa el filtro adicional como **kwargs
        filter_params['estatus'] = filter_status
        
    # Llamada a la funci√≥n con **kwargs
    classified_data = utils.classify_by_rarity(artifacts, **filter_params)
    
    print("\nüì¶ ARTEFACTOS CLASIFICADOS:")
    for rarity, items in classified_data.items():
        print(f"  ## {rarity.upper()} ({len(items)}) ##")
        for item in items:
            print(f"    - [{item['codigo']}] {item['descripcion']} | Estatus: {item['estatus']}")
            
def get_artifact_stats():
    """Calcula y muestra estad√≠sticas de artefactos."""
    artifacts = load_artifacts()
    
    stats = {}
    
    # Total de artefactos
    stats['total_artefactos'] = len(artifacts)
    
    if not artifacts:
        utils.display_statistics(stats, "Artefactos", "Informaci√≥n General")
        return
        
    # Artefactos por rareza (usando un diccionario)
    rarity_count = {}
    for a in artifacts:
        rarity = a['rareza']
        rarity_count[rarity] = rarity_count.get(rarity, 0) + 1
    
    stats['artefactos_por_rareza'] = rarity_count
    
    # Artefactos por estatus (usando un diccionario)
    status_count = {}
    for a in artifacts:
        status = a['estatus']
        status_count[status] = status_count.get(status, 0) + 1
        
    stats['estado_artefactos'] = status_count

    # Usa la funci√≥n auxiliar con *args para t√≠tulos
    utils.display_statistics(
        stats, 
        "General", 
        "Por Nivel de Rareza", 
        "Por Estatus"
    )

def delete_artifact():
    """Elimina un artefacto. (Opci√≥n B: Marcar 'Destruido')."""
    code = input("Ingrese el C√≥digo del artefacto a ELIMINAR (marcar): ").strip()
    artifacts = load_artifacts()
    
    for i, a in enumerate(artifacts):
        if a['codigo'] == code:
            
            # Marcar "Destruido" en el campo 'estatus'
            artifacts[i]['estatus'] = 'Destruido' 
            
            if save_artifacts(artifacts):
                print(f"\n‚úÖ Artefacto **{a['descripcion']}** marcado como **Destruido**.")
            else:
                print("\n‚ùå Error al guardar la eliminaci√≥n.")
            return

    print(f"\n‚ùå Artefacto con C√≥digo **{code}** no encontrado.")
6. main.py (Men√∫ Principal)
Este m√≥dulo es el punto de entrada, maneja el flujo de la aplicaci√≥n y la llamada a los men√∫s.

Python

import auth
import visitors
import artifacts
import os
import sys

def clear_screen():
    """Limpia la consola para una mejor experiencia."""
    os.system('cls' if os.name == 'nt' else 'clear')

def visitors_menu():
    """Men√∫ de gesti√≥n de Visitantes Intergal√°cticos."""
    while True:
        print("\n\n--- üöÄ M√ìDULO DE VISITANTES INTERGAL√ÅCTICOS ---")
        print("1. Registrar visitante")
        print("2. Listar visitantes")
        print("3. Buscar visitante por ID")
        print("4. Actualizar estado")
        print("5. Eliminar visitante (Marcar 'Eliminado')")
        print("6. Estad√≠sticas de visitantes")
        print("0. Volver al Men√∫ Principal")
        
        choice = input("Seleccione una opci√≥n: ")
        clear_screen()
        
        if choice == '1':
            visitors.register_visitor()
        elif choice == '2':
            visitors.list_visitors()
        elif choice == '3':
            visitors.search_visitor()
        elif choice == '4':
            visitors.update_visitor_status()
        elif choice == '5':
            visitors.delete_visitor()
        elif choice == '6':
            visitors.get_visitor_stats()
        elif choice == '0':
            break
        else:
            print("‚ö†Ô∏è Opci√≥n no v√°lida. Intente de nuevo.")

def artifacts_menu():
    """Men√∫ de gesti√≥n de Artefactos Recuperados."""
    while True:
        print("\n\n--- üíé M√ìDULO DE ARTEFACTOS RECUPERADOS ---")
        print("1. Registrar artefacto")
        print("2. Listar artefactos")
        print("3. Buscar artefacto por C√≥digo")
        print("4. Clasificar artefactos por rareza (**kwargs)")
        print("5. Estad√≠sticas de artefactos")
        print("6. Eliminar artefacto (Marcar 'Destruido')")
        print("0. Volver al Men√∫ Principal")
        
        choice = input("Seleccione una opci√≥n: ")
        clear_screen()
        
        if choice == '1':
            artifacts.register_artifact()
        elif choice == '2':
            artifacts.list_artifacts()
        elif choice == '3':
            artifacts.search_artifact()
        elif choice == '4':
            artifacts.classify_artifacts_menu()
        elif choice == '5':
            artifacts.get_artifact_stats()
        elif choice == '6':
            artifacts.delete_artifact()
        elif choice == '0':
            break
        else:
            print("‚ö†Ô∏è Opci√≥n no v√°lida. Intente de nuevo.")


def main_menu():
    """Men√∫ principal del sistema Galactic Library Keeper."""
    while True:
        print("\n\n=== üåå GALACTIC LIBRARY KEEPER v1.0 ===")
        print("1. Gestionar Visitantes Intergal√°cticos")
        print("2. Gestionar Artefactos Recuperados")
        print("0. Salir del Sistema")
        
        choice = input("Seleccione un m√≥dulo: ")
        clear_screen()
        
        if choice == '1':
            visitors_menu()
        elif choice == '2':
            artifacts_menu()
        elif choice == '0':
            print("\nüëã Gracias por usar Galactic Library Keeper. ¬°Apagado seguro!")
            sys.exit(0)
        else:
            print("‚ö†Ô∏è Opci√≥n no v√°lida. Intente de nuevo.")

if __name__ == "__main__":
    clear_screen()
    print("-----------------------------------------------------")
    print("--- INICIANDO GALACTIC LIBRARY KEEPER (2487) ---")
    print("-----------------------------------------------------")

    # 1. Inicio de sesi√≥n del administrador (recursivo)
    if auth.login():
        clear_screen()
        main_menu()
    else:
        # El login ya maneja el mensaje de denegado y salida si se agotan los intentos
        sys.exit(1)
üìÑ README.md (Entregable de Explicaci√≥n)
Galactic Library Keeper ‚Äî Sistema de Gesti√≥n de Archivos Interplanetarios
Este es el primer m√≥dulo del sistema Galactic Library Keeper, un software de consola desarrollado en Python para modernizar la gesti√≥n de datos en las estaciones espaciales de la Federaci√≥n Intergal√°ctica, garantizando la persistencia de la informaci√≥n mediante archivos CSV.

1. Funcionalidad Principal
El sistema permite la gesti√≥n de dos entidades principales: Visitantes Intergal√°cticos y Artefactos Recuperados. Requiere un inicio de sesi√≥n de administrador √∫nico antes de acceder a los m√≥dulos de gesti√≥n.

2. Persistencia de Datos (Archivos CSV)
La persistencia de datos es un requisito fundamental. Todos los datos se almacenan en archivos CSV (Comma Separated Values), lo que garantiza que la informaci√≥n se guarde en disco inmediatamente despu√©s de cada operaci√≥n de registro, actualizaci√≥n o eliminaci√≥n (marcada).

storage.py es el m√≥dulo central que maneja la lectura (load_data) y escritura (save_data) de datos, asegurando que los archivos CSV se creen si no existen.

Archivos utilizados: admin_access.csv, visitantes.csv, artefactos.csv.

3. Uso Obligatorio de Colecciones
Colecci√≥n	D√≥nde se usa	Prop√≥sito
Listas (list)	storage.py, visitors.py, artifacts.py	Colecci√≥n principal para cargar todas las filas de los CSV en memoria.
Diccionarios (dict)	visitors.py, artifacts.py	Representaci√≥n de cada entidad (visitante, artefacto, administrador). Tambi√©n se usa en las funciones de estad√≠sticas para contar elementos.
Tuplas (tuple)	utils.py (funci√≥n format_data_for_display)	Se usan para formatear y mostrar los datos de visitantes/artefactos en los listados, garantizando que los datos visualizados no sean modificados accidentalmente.
Sets (set)	visitors.py (get_visitor_ids), artifacts.py (get_artifact_codes)	Se usan para almacenar temporalmente todos los IDs/C√≥digos √∫nicos de las entidades cargadas, permitiendo una validaci√≥n r√°pida y eficiente de duplicados durante el registro de nuevos elementos.

Exportar a Hojas de c√°lculo

4. Requisitos de Funciones Avanzadas
Requisito	Funci√≥n y M√≥dulo	Explicaci√≥n
Funci√≥n Recursiva	auth.py (login)	Se usa para manejar el proceso de inicio de sesi√≥n. Si el usuario ingresa credenciales incorrectas, la funci√≥n se llama a s√≠ misma (return login(attempts - 1)) con un contador de intentos decreciente hasta llegar a 0.
Funci√≥n con *args	utils.py (display_statistics)	Se utiliza para aceptar un n√∫mero variable de subt√≠tulos o encabezados para el reporte de estad√≠sticas, haciendo la funci√≥n flexible. Ejemplo de uso: display_statistics(stats, "General", "Por Especie").
Funci√≥n con **kwargs	utils.py (classify_by_rarity)	Se utiliza para implementar la clasificaci√≥n de artefactos. Permite pasar filtros opcionales como argumentos de palabra clave (ej. estatus='Almacenado'), clasificando solo los artefactos que coincidan con estos filtros.

Exportar a Hojas de c√°lculo

5. Decisi√≥n de Eliminaci√≥n de Visitantes/Artefactos
Se eligi√≥ la Opci√≥n B: Marcar "Eliminado" / "Destruido" en el campo estado o estatus.

Justificaci√≥n: En un sistema de gesti√≥n de archivos, especialmente para registros cr√≠ticos (visitantes, artefactos), la eliminaci√≥n f√≠sica de una fila (Opci√≥n A) se considera una mala pr√°ctica ya que elimina el historial y puede romper la integridad de datos referenciados. Marcar el registro como "Eliminado" o "Destruido" mantiene la integridad hist√≥rica y permite auditor√≠as futuras (una pr√°ctica com√∫n conocida como Soft Delete).

6. Diagrama de Flujo Simple

¬°Entendido! Me pides una explicaci√≥n m√°s detallada, a modo de documentaci√≥n formal, sobre los elementos obligatorios que se utilizaron en el c√≥digo para cumplir con los requisitos t√©cnicos.Aqu√≠ tienes la documentaci√≥n, separada por componentes y con ejemplos de su uso en el proyecto Galactic Library Keeper.üìö Documentaci√≥n T√©cnica del Sistema GLKEste sistema utiliza caracter√≠sticas esenciales de Python para garantizar la persistencia de datos y la robustez del c√≥digo.1. Persistencia de Datos con CSVLa persistencia es la capacidad de la aplicaci√≥n de almacenar datos de forma que sobrevivan al final del proceso. Elegimos el formato CSV (Comma Separated Values) debido a su simplicidad y accesibilidad, cumpliendo con la directriz de accesibilidad simple para terminales viejas.M√≥dulo Clave: storage.pyFunci√≥nDescripci√≥nAplicaci√≥n en GLKload_data(filename, default_header)Lee un archivo CSV y lo convierte en una Lista de Diccionarios. Si el archivo no existe, lo crea con el encabezado.Utilizada al iniciar el sistema para cargar credenciales de administrador, y al inicio de cualquier operaci√≥n (listar, buscar, modificar).save_data(filename, data_list, header)Escribe una Lista de Diccionarios de vuelta al archivo CSV, sobrescribiendo el contenido anterior.Utilizada inmediatamente despu√©s de registrar, actualizar o eliminar (marcar) una entidad para garantizar que los datos est√©n guardados en disco.Garant√≠a: Al usar mode='w' (write) en save_data, se asegura que cada operaci√≥n de modificaci√≥n o adici√≥n reescriba el archivo completo, haciendo los datos persistentes incluso si la terminal se apaga despu√©s de la escritura exitosa.2. Uso Obligatorio de ColeccionesEl proyecto integra las cuatro colecciones fundamentales de Python para tareas espec√≠ficas.2.1. Listas y DiccionariosListas (list): Contenedores ordenados y mutables. Se usan como la estructura principal en memoria.Uso: La funci√≥n load_data siempre retorna una lista de diccionarios, y esta lista es la que se manipula en los m√≥dulos visitors.py y artifacts.py.Diccionarios (dict): Contenedores de pares clave-valor. Son la representaci√≥n at√≥mica de cada entidad.Uso: Cada visitante y cada artefacto se almacena como un diccionario, facilitando el acceso a los datos por nombre de columna (ej.: visitante['nombre']). Tambi√©n se usan extensivamente en las funciones de estad√≠sticas para realizar conteos (ej.: {'EspecieA': 15, 'EspecieB': 8}).2.2. Sets (Conjuntos)Sets (set): Colecci√≥n desordenada de elementos √∫nicos. Ideal para validaciones r√°pidas.Uso: En visitors.py y artifacts.py, las funciones get_visitor_ids y get_artifact_codes usan set comprehensions para obtener todos los IDs existentes.$$ids = \{v['id'] \text{ for } v \text{ in } visitors\_list\}$$Beneficio: Consultar si un nuevo ID existe en un set (if new_id in ids) es extremadamente r√°pido (tiempo $O(1)$) en comparaci√≥n con iterar sobre una lista grande (tiempo $O(n)$).2.3. TuplasTuplas (tuple): Colecci√≥n ordenada e inmutable (no se puede modificar despu√©s de la creaci√≥n).Uso: En utils.py, la funci√≥n format_data_for_display convierte la lista de diccionarios a una lista de tuplas antes de mostrarla.Beneficio: Garantiza que los datos mostrados en el men√∫ de "Listar" sean inalterables, previniendo errores de modificaci√≥n accidental en la capa de visualizaci√≥n.3. Uso Obligatorio de Funciones AvanzadasEl proyecto utiliza argumentos din√°micos y recursividad para manejar flujos de control complejos.3.1. Funci√≥n Recursiva: login()Una funci√≥n recursiva es aquella que se llama a s√≠ misma para resolver un problema.Funci√≥n: auth.py -> login(attempts=3)Mecanismo: La funci√≥n maneja la autenticaci√≥n y, si falla, se llama a s√≠ misma con el n√∫mero de intentos reducido:Python# ... si el login falla ...
return login(attempts - 1)
Condici√≥n de Parada: El caso base (condici√≥n de parada) es cuando attempts == 0, lo que previene una recursi√≥n infinita y deniega el acceso.3.2. Funci√≥n con *args*args permite pasar un n√∫mero variable de argumentos posicionales a una funci√≥n, los cuales se reciben como una tupla.Funci√≥n: utils.py -> display_statistics(stats_dict, *args)Uso: Los *args se utilizan para pasar t√≠tulos o subt√≠tulos din√°micos al reporte de estad√≠sticas.Python# Ejemplo de llamada desde visitors.py:
utils.display_statistics(stats, "General", "Por Especie", "Por Estado")

# Dentro de la funci√≥n, *args ser√≠a:
# args = ('General', 'Por Especie', 'Por Estado')
3.3. Funci√≥n con **kwargs**kwargs permite pasar un n√∫mero variable de argumentos con nombre (clave=valor) a una funci√≥n, los cuales se reciben como un diccionario.Funci√≥n: utils.py -> classify_by_rarity(data_list, **kwargs)Uso: Se utiliza para permitir la clasificaci√≥n de artefactos con filtros opcionales.Python# Ejemplo de llamada desde artifacts.py:
# Si el usuario quiere filtrar solo los 'Almacenado':
filter_params = {'estatus': 'Almacenado'} 
classified_data = utils.classify_by_rarity(artifacts, **filter_params)

# Dentro de la funci√≥n, **kwargs ser√≠a:
# kwargs = {'estatus': 'Almacenado'}
Mecanismo: La funci√≥n itera sobre el diccionario kwargs para aplicar din√°micamente cualquier filtro adicional antes de realizar la clasificaci√≥n principal por rareza.